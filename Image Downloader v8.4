
    // ==UserScript==
    // @name         Universal Image Downloader
    // @namespace    https://greasyfork.org/en/users/1553223-ozler365
    // @version      8.4
    // @description  Professional UI, Smart Source Scan (No Scroll), and Strict Reader Isolation
    // @author       ozler365
    // @license      MIT
    // @connect      *
    // @grant        GM_xmlhttpRequest
    // @grant        GM_download
    // @grant        GM_registerMenuCommand
    // @require      https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js
    // @require      https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js
    // @run-at       document-end
    // @match        *://*/*
    // ==/UserScript==
     
    /* jshint esversion: 6 */
    /* eslint-env es6 */
     
    (function () {
        'use strict';
     
        // 1. Configuration & Localization
        const isZh = (navigator.language || 'en').toLowerCase().includes("zh");
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
     
        const i18n = {
            subFolder: isZh ? "文件夹名称" : "Folder Name",
            selectAll: isZh ? "全选" : "Select All",
            download: isZh ? "批量下载" : "Download All",
            zip: isZh ? "打包下载" : "ZIP Pack",
            selected: isZh ? "已选择" : "Selected",
            rename: isZh ? "重命名" : "Rename",
            original: isZh ? "原名" : "Original",
            menuOpen: isZh ? "启动下载器" : "Open Downloader",
        };
     
        // 2. Helper Functions
        function getAbsUrl(url) {
            if (!url || typeof url !== 'string' || url.startsWith('blob:') || url.startsWith('data:')) return url;
            try { return new URL(url, document.baseURI).href; } catch(e) { return url; }
        }
     
        // --- IMPROVED FILENAME SANITIZER ---
        function getFilename(url) {
            try {
                const u = new URL(url, document.baseURI);
                let name = u.pathname.split('/').pop();
     
                // Handle cases where path ends in slash or is empty
                if (!name) {
                    const parts = u.pathname.split('/').filter(x => x);
                    if (parts.length > 0) name = parts[parts.length - 1];
                }
     
                // Fallback to hostname if absolutely no name found
                if (!name) name = u.hostname.replace(/\./g, '_');
     
                // Decode and Sanitization
                name = decodeURIComponent(name);
                // Replace ALL illegal characters and slashes to force flat filename
                return name.replace(/[\\/:*?"<>|]/g, '_');
            } catch(e) {
                // Fallback for data URIs or weird strings
                return 'image_' + Date.now();
            }
        }
     
        async function getImageBlob(url) {
            return new Promise((resolve, reject) => {
                if (url.startsWith('data:') || url.startsWith('blob:')) {
                    fetch(url).then(res => res.blob()).then(resolve).catch(reject);
                    return;
                }
                GM_xmlhttpRequest({
                    method: "GET",
                    url: url,
                    responseType: "blob",
                    anonymous: false,
                    headers: {
                        "Referer": window.location.href,
                        "Accept": "image/avif,image/webp,image/apng,image/*,*/*;q=0.8"
                    },
                    onload: (res) => {
                        if (res.status === 200 && res.response.size > 512) resolve(res.response);
                        else fetch(url).then(r => r.blob()).then(resolve).catch(reject);
                    },
                    onerror: () => fetch(url).then(r => r.blob()).then(resolve).catch(reject)
                });
            });
        }
     
        async function convertToJpeg(blob) {
            return new Promise((resolve) => {
                const img = new Image();
                const url = URL.createObjectURL(blob);
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width; canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#FFF'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    canvas.toBlob(b => { URL.revokeObjectURL(url); resolve(b || blob); }, 'image/jpeg', 0.9);
                };
                img.onerror = () => { URL.revokeObjectURL(url); resolve(blob); };
                img.src = url;
            });
        }
     
        function getImageDimensions(url) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve({ width: img.width, height: img.height, valid: true });
                img.onerror = () => resolve({ width: 0, height: 0, valid: false });
                img.src = url;
                setTimeout(() => resolve({ width: 0, height: 0, valid: false }), 3000);
            });
        }
     
        function getElementPosition(el) {
            const rect = el.getBoundingClientRect();
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            return {
                top: rect.top + scrollTop,
                left: rect.left + scrollLeft
            };
        }
     
        // 3. Main UI Logic
        function openUI() {
            if (document.querySelector(".tyc-overlay")) return;
     
            const styles = `
                .tyc-overlay { position:fixed; top:0; left:0; width:100%; height:100%; background:transparent; z-index:2147483640; display:flex; justify-content:center; align-items:center; font-family:-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; pointer-events: none; }
                .tyc-modal { width:90vw; height:85vh; background:#fcfcfc; border-radius:12px; display:flex; flex-direction:column; overflow:hidden; resize:both; min-width:600px; box-shadow: 0 10px 40px rgba(0,0,0,0.4); border: 1px solid #444; pointer-events: auto; }
                .tyc-header { padding:15px 25px; background:#fff; border-bottom:1px solid #e0e0e0; display:flex; align-items:center; gap:15px; flex-wrap:wrap; box-shadow: 0 2px 5px rgba(0,0,0,0.03); z-index: 10; cursor:move; user-select:none; }
                .tyc-header * { cursor: default; }
                .tyc-input { padding:8px 12px; border:2px solid #ccc !important; border-radius:6px; font-weight:600; width:140px; background-color: #ffffff !important; color: #222 !important; box-shadow: inset 0 1px 3px rgba(0,0,0,0.05); font-size: 14px; cursor:text !important; }
                .tyc-input:focus { border-color: #007bff !important; outline: none; }
                .tyc-btn { padding:8px 16px; border-radius:6px; border:none; cursor:pointer !important; font-weight:700; font-size:13px; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); color: white; min-width: 80px; }
                .tyc-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); filter: brightness(110%); }
                .tyc-btn:active { transform: translateY(0); box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
                .tyc-btn-blue { background: linear-gradient(135deg, #007bff, #0062cc); }
                .tyc-btn-green { background: linear-gradient(135deg, #28a745, #218838); }
                .tyc-btn-gray { background: #f8f9fa; color: #333; border: 1px solid #ddd; }
                .tyc-btn-gray:hover { background: #e2e6ea; }
                .tyc-badge { background:#333; color:#fff; padding:6px 12px; border-radius:20px; font-weight:700; font-size: 12px; white-space: nowrap; }
                .tyc-label { display:flex; align-items:center; gap:8px; cursor:pointer !important; font-weight: 600; color: #444; user-select: none; }
                .tyc-label input { cursor:pointer !important; }
                .tyc-grid { flex:1; overflow-y:auto; padding:20px; display:grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); grid-auto-rows: 260px; gap:15px; background:#f0f2f5; }
                .tyc-card { background:#fff; border-radius:8px; border:3px solid transparent; cursor:pointer !important; overflow:hidden; display:flex; align-items:center; justify-content:center; box-shadow:0 2px 8px rgba(0,0,0,0.06); transition: transform 0.1s; position: relative; }
                .tyc-card:hover { transform: scale(1.02); }
                .tyc-card.selected { border-color:#007bff; background:#edf5ff; }
                .tyc-card.selected::after { content:"✓"; position:absolute; top:5px; right:5px; background:#007bff; color:white; width:24px; height:24px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:bold; font-size:14px; }
                .tyc-card img { max-width:95%; max-height:95%; object-fit:contain; pointer-events:none; }
     
                @media screen and (max-width: 768px) {
                    .tyc-modal { width: 95vw; height: 80vh; min-width: unset; border-radius: 8px; }
                    .tyc-header { padding: 8px; gap: 6px; }
                    .tyc-input { width: 70px; font-size: 12px; padding: 4px; }
                    .tyc-btn { padding: 5px 8px; font-size: 11px; min-width: auto; }
                    .tyc-grid { padding: 8px; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); grid-auto-rows: 140px; gap: 6px; }
                    .tyc-badge { font-size: 10px; padding: 4px 8px; }
                }
            `;
     
            const html = `
                <div class="tyc-overlay">
                    <style>${styles}</style>
                    <div class="tyc-modal" id="tyc-modal">
                        <div class="tyc-header" id="tyc-drag-handle">
                            <label class="tyc-label">
                                <input type="checkbox" id="tyc-select-all" style="width:18px; height:18px;" checked>
                                <span>${i18n.selectAll}</span>
                            </label>
                            <div style="height:25px; border-left:1px solid #ddd; margin:0 5px;"></div>
                            <input type="text" id="tyc-folder" class="tyc-input" placeholder="${i18n.subFolder}">
     
                            <button class="tyc-btn tyc-btn-gray" id="tyc-rename-btn">${i18n.rename}</button>
     
                            <span class="tyc-badge" id="tyc-count">0</span>
                            <div style="flex:1;"></div>
                            <button class="tyc-btn tyc-btn-blue" id="tyc-download">${i18n.download}</button>
                            <button class="tyc-btn tyc-btn-green" id="tyc-zip">${i18n.zip}</button>
                            <button class="tyc-btn tyc-btn-gray" id="tyc-close-btn" style="padding: 8px 12px; font-size: 16px; min-width: 40px;">✕</button>
                        </div>
                        <div class="tyc-grid" id="tyc-grid"></div>
                    </div>
                </div>
            `;
     
            document.body.insertAdjacentHTML("beforeend", html);
     
            // Make modal draggable
            const modal = document.getElementById("tyc-modal");
            const dragHandle = document.getElementById("tyc-drag-handle");
            let isDragging = false;
            let offsetX = 0, offsetY = 0;
     
            dragHandle.addEventListener("mousedown", (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON' || e.target.tagName === 'LABEL') {
                    return;
                }
                isDragging = true;
                const rect = modal.getBoundingClientRect();
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;
                dragHandle.style.cursor = 'grabbing';
                e.preventDefault();
            });
     
            document.addEventListener("mousemove", (e) => {
                if (!isDragging) return;
                const x = e.clientX - offsetX;
                const y = e.clientY - offsetY;
                modal.style.position = 'fixed';
                modal.style.left = x + 'px';
                modal.style.top = y + 'px';
                modal.style.margin = '0';
            });
     
            document.addEventListener("mouseup", () => {
                if (isDragging) {
                    isDragging = false;
                    dragHandle.style.cursor = 'move';
                }
            });
     
            // --- VARIABLES ---
            const grid = document.getElementById("tyc-grid");
            const countBadge = document.getElementById("tyc-count");
            let selectedIndices = new Set();
            let imgUrls = [];
            let seenUrls = new Set();
            // Removed seenFilenames to fix Google Images fetching
            let refreshInterval;
            let isScanning = false;
     
            // --- COMPREHENSIVE DOM SCANNER ---
            const scanDOM = async () => {
                if (isScanning) return [];
                isScanning = true;
     
                const tempUrls = [];
                const imgRegex = /\.(jpg|jpeg|png|webp|avif|bmp|gif)($|\?)/i;
                const locationHref = window.location.href;
     
                const elements = document.querySelectorAll('img, div, span, a, section, header, main, article, li, figure');
                const ignoredTags = ['SCRIPT', 'STYLE', 'LINK', 'META', 'NOSCRIPT', 'TEXTAREA', 'OPTION', 'SELECT', 'INPUT', 'BUTTON', 'SVG', 'PATH', 'USE'];
     
                for (const el of elements) {
                    if (!el.tagName || ignoredTags.includes(el.tagName.toUpperCase())) continue;
     
                    let candidates = [];
     
                    if (el.tagName === 'IMG') {
                        const attrs = [
                            el.getAttribute('data-original'),
                            el.getAttribute('data-src'),
                            el.dataset.src,
                            el.getAttribute('data-lazy-src'),
                            el.getAttribute('data-srcset'),
                            el.getAttribute('data-image'),
                            el.getAttribute('data-img'),
                            el.currentSrc,
                            el.src
                        ];
                        attrs.forEach(src => {
                            if (src) candidates.push({ url: src, w: el.naturalWidth, h: el.naturalHeight });
                        });
                    } else {
                        if (el.offsetWidth > 0 || el.offsetHeight > 0) {
                            const bg = window.getComputedStyle(el).backgroundImage;
                            if (bg && bg.startsWith('url(')) {
                                const matches = bg.match(/url\(['"]?([^'"]+)['"]?\)/g);
                                if (matches) {
                                    matches.forEach(match => {
                                        const url = match.replace(/url\(['"]?|['"]?\)/g, '');
                                        candidates.push({ url: url, w: 0, h: 0 });
                                    });
                                }
                            }
                        }
                    }
     
                    let bestCandidate = null;
                    for (let item of candidates) {
                        let src = item.url;
                        if (!src || src === locationHref) continue;
     
                        if (!src.startsWith('http') && !src.startsWith('blob:') && !src.startsWith('data:')) {
                            try { src = new URL(src, locationHref).href; } catch (e) { continue; }
                        }
     
                        let score = 0;
                        if (src.startsWith('http')) score = 3;
                        else if (src.startsWith('blob:')) score = 2;
                        else if (src.startsWith('data:')) score = 1;
     
                        if (!bestCandidate || score > bestCandidate.score) {
                            bestCandidate = { src, w: item.w, h: item.h, score };
                        }
                    }
     
                    if (bestCandidate) {
                        const url = bestCandidate.src;
                        if (url.startsWith('data:image/svg')) continue;
     
                        // FIX: We do NOT filter by filename here anymore.
                        // This was what broke Google Images (all named 'images').
                        if (seenUrls.has(url)) continue;
     
                        const dims = await getImageDimensions(url);
                        if (!dims.valid || dims.width < 50 || dims.height < 50) continue;
     
                        seenUrls.add(url);
                        const pos = getElementPosition(el);
                        tempUrls.push({ url, position: pos });
                    }
                }
     
                tempUrls.sort((a, b) => {
                    const topDiff = a.position.top - b.position.top;
                    if (Math.abs(topDiff) > 10) return topDiff;
                    return a.position.left - b.position.left;
                });
     
                isScanning = false;
                return tempUrls.map(item => item.url);
            };
     
            const render = () => {
                const currentCount = grid.children.length;
                const selectAll = document.getElementById("tyc-select-all");
                const isSelectAll = selectAll && selectAll.checked;
     
                for (let index = currentCount; index < imgUrls.length; index++) {
                    if (isSelectAll) selectedIndices.add(index);
                    const url = imgUrls[index];
                    const card = document.createElement("div");
                    card.className = "tyc-card";
                    if (selectedIndices.has(index)) card.classList.add("selected");
                    card.innerHTML = `<img src="${url}" loading="lazy" onerror="this.parentElement.remove()">`;
                    card.onclick = () => {
                        if (selectedIndices.has(index)) {
                            selectedIndices.delete(index);
                            card.classList.remove("selected");
                        } else {
                            selectedIndices.add(index);
                            card.classList.add("selected");
                        }
                        countBadge.innerText = `${i18n.selected}: ${selectedIndices.size}`;
                    };
                    grid.appendChild(card);
                }
                countBadge.innerText = `${i18n.selected}: ${selectedIndices.size}`;
            };
     
            const refreshImages = async () => {
                const newUrls = await scanDOM();
                if (newUrls.length > 0) {
                    imgUrls.push(...newUrls);
                    render();
                }
            };
     
            refreshImages();
            refreshInterval = setInterval(refreshImages, 3000);
     
            // Rename Toggle Handler
            document.getElementById("tyc-rename-btn").onclick = function() {
                this.innerText = (this.innerText === i18n.rename) ? i18n.original : i18n.rename;
            };
     
            document.getElementById("tyc-select-all").onchange = (e) => {
                const isChecked = e.target.checked;
                selectedIndices.clear();
                document.querySelectorAll(".tyc-card").forEach((card, idx) => {
                    if (isChecked) { selectedIndices.add(idx); card.classList.add("selected"); }
                    else { card.classList.remove("selected"); }
                });
                countBadge.innerText = `${i18n.selected}: ${selectedIndices.size}`;
            };
     
            document.getElementById("tyc-close-btn").onclick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                clearInterval(refreshInterval);
                const overlay = document.querySelector(".tyc-overlay");
                if (overlay) overlay.remove();
            };
     
            // --- DOWNLOAD HANDLER ---
            document.getElementById("tyc-download").onclick = async function() {
                const selected = Array.from(selectedIndices).sort((a,b)=>a-b);
                const btn = this;
                const folderInput = document.getElementById("tyc-folder").value.trim();
                const folderPrefix = folderInput ? folderInput + "/" : "";
                const shouldRename = document.getElementById("tyc-rename-btn").innerText === i18n.rename;
                const usedNames = new Set(); // Track filenames to prevent overwrites
     
                btn.disabled = true;
                const downloadDelay = isMobile ? 1500 : 250;
     
                for (let i = 0; i < selected.length; i++) {
                    btn.innerText = `${i+1}/${selected.length}`;
                    try {
                        const blob = await getImageBlob(imgUrls[selected[i]]);
                        const jpeg = await convertToJpeg(blob);
     
                        let fileName;
                        if (shouldRename) {
                            const imgIndex = selected[i] + 1;
                            fileName = `image${imgIndex}.jpg`;
                        } else {
                            fileName = getFilename(imgUrls[selected[i]]);
                            if (!fileName.match(/\.(jpg|jpeg|png|webp|avif|bmp|gif)$/i)) {
                                fileName += '.jpg';
                            }
                            // Handle collision if "Original" was selected
                            let baseName = fileName;
                            let counter = 1;
                            while(usedNames.has(fileName)) {
                                 const dotIndex = baseName.lastIndexOf('.');
                                 if(dotIndex > -1) {
                                     fileName = baseName.substring(0, dotIndex) + `_${counter}` + baseName.substring(dotIndex);
                                 } else {
                                     fileName = baseName + `_${counter}`;
                                 }
                                 counter++;
                            }
                            usedNames.add(fileName);
                        }
     
                        if (!isMobile && typeof GM_download === 'function') {
                            const bUrl = URL.createObjectURL(jpeg);
                            GM_download({
                                url: bUrl,
                                name: folderPrefix + fileName,
                                onload: () => URL.revokeObjectURL(bUrl)
                            });
                        } else {
                            saveAs(jpeg, fileName);
                        }
                    } catch(e) { console.error(e); }
     
                    await new Promise(r => setTimeout(r, downloadDelay));
                }
                btn.innerText = i18n.download;
                btn.disabled = false;
            };
     
            document.getElementById("tyc-zip").onclick = async function() {
                const selected = Array.from(selectedIndices).sort((a,b)=>a-b);
                const btn = this;
                const zip = new JSZip();
                const title = document.title.replace(/[\\/:*?"<>|]/g, "_");
                const shouldRename = document.getElementById("tyc-rename-btn").innerText === i18n.rename;
                const usedNames = new Set(); // Track filenames in ZIP
     
                btn.disabled = true;
                for (let i = 0; i < selected.length; i++) {
                    btn.innerText = `ZIP ${Math.round(((i+1)/selected.length)*100)}%`;
                    try {
                        const blob = await getImageBlob(imgUrls[selected[i]]);
                        const jpeg = await convertToJpeg(blob);
     
                        let fileName;
                        if (shouldRename) {
                            const imgIndex = selected[i] + 1;
                            fileName = `image${imgIndex}.jpg`;
                        } else {
                            fileName = getFilename(imgUrls[selected[i]]);
                            if (!fileName.match(/\.(jpg|jpeg|png|webp|avif|bmp|gif)$/i)) {
                                fileName += '.jpg';
                            }
                            // Handle collision inside ZIP
                            let baseName = fileName;
                            let counter = 1;
                            while(usedNames.has(fileName)) {
                                 const dotIndex = baseName.lastIndexOf('.');
                                 if(dotIndex > -1) {
                                     fileName = baseName.substring(0, dotIndex) + `_${counter}` + baseName.substring(dotIndex);
                                 } else {
                                     fileName = baseName + `_${counter}`;
                                 }
                                 counter++;
                            }
                            usedNames.add(fileName);
                        }
     
                        zip.file(fileName, jpeg);
                    } catch(e) { console.error(e); }
                }
                zip.generateAsync({type:"blob"}).then(c => {
                    saveAs(c, `${title}.zip`);
                    btn.innerText = i18n.zip;
                    btn.disabled = false;
                });
            };
        }
     
        window.addEventListener('keydown', (e) => {
            if (e.altKey && e.code === 'KeyW') {
                e.preventDefault();
                const existing = document.querySelector(".tyc-overlay");
                if (existing) existing.remove(); else openUI();
            }
        }, true);
     
        if (typeof GM_registerMenuCommand === "function") {
            GM_registerMenuCommand(i18n.menuOpen, openUI);
        }
    })();

